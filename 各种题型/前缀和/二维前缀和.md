Problem L Largest Allowed Area

A company is looking for land to build its headquarters. It has a lot of money and can buy as
many land patches as it needs. Its goal, however, is finding the largest square region
containing no forest. Unfortunately, there is no such region that is large enough for the
headquarters they want to build.
After negotiation with the government and the evaluation of environmental impacts, the
government allows the company to purchase land with at most one forest patch. In other
words, the companyâ€™s goal is now finding the largest square region containing at most one
forest patch.
To facilitate the search process, the company creates a map in the form of a 2D table
consisting R rows and C columns. In this 2D table, each entry represents a land of patch
where 0 corresponds to a non-forest patch and 1 to a forest patch. Unfortunately, the map
may have up to 1,000 x 1,000 entries and it is not a good idea to manually look for the largest
allowed square region. This is where your skill comes into play. Write an efficient algorithm
to find such a square region.
Input:
The first line is a positive integer T <= 20 representing the number of test cases. For each
case, the input is formatted as follows.
First line R C
where R and C represents the number of rows and columns in the
map. Also, 5 <= R, C <= 1,000
Next R lines Each line represents a row in the map from the first to last. It has C
numbers which are 0 or 1, separated by one space.
Note: there is at least one non-forest patch in each test case.
Output:
There are T lines in the output. Each line is the number of rows in the largest allowed square
region for each case.

Input
2
10 20
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 1 0 0 0 0 0 0 1 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0
20 10
1 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 1 0
0 0 1 0 0 0 0 1 1 0
0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 1
0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 1 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0
0 0 1 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0 0 0

Output
9
7
```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAX_N = 1e3 + 5;
int r, c;
int T;
int a[MAX_N][MAX_N];
int sum[MAX_N][MAX_N];

inline int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while (ch<'0' || ch>'9') { if (ch == '-')w = -1; ch = getchar(); }
	while (ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
	return s * w;
}

int main()
{
	cin >> T;
	while (T--)
	{
		cin >> r >> c;
		for (int i = 0; i <= r; i++)
		{
			for (int j = 0; j <= c; j++)
			{
				sum[i][j] = 0;
			}
		}
		getchar();
		for (int i = 1; i <= r; i++)
		{
			for (int j = 1; j <= c; j++)
			{
				a[i][j] = read();
				sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + a[i][j];
			}
		}
		int ans = 1;
		for (int i = 1; i <= r; i++)
		{
			for (int j = 1; j <= c; j++)
			{
				for (int len = ans; len + i <= r && len + j  <= c; len++)
				{
					int dr = i + len ;
					int dc = j + len;
					if (sum[dr][dc] - sum[dr][j - 1] - sum[i - 1][dc] + sum[i - 1][j - 1] <= 1)
					{
						ans = len;
					}
					else break;
				}
			}
		}
		cout << ans +1<< endl;
	}
}
```
