## 分块
### P5356 Ynoi2017_由乃打扑克

[P5356 [Ynoi2017]由乃打扑克](https://www.luogu.com.cn/problem/P5356)

题意：
给你一个长为 nnn 的序列 aaa，需要支持 mmm 次操作，操作有两种：

    查询区间 [l,r] 的第 k 小值。
    
    区间 [l,r] 加上 k。

题解：

调了几天的题，内容过于丰富，用到了分块、二分、归并排序的思想。好题

详情见代码

```c++
const int N = 1e5 +10;
int K, n, m, sum;//sum是和 
int block, L[N], R1[N];
// 桶标记
int tag[N];

PII a[N<<1]; // 数和序号
PII A[N], B[N];

// 二分，求出在这个桶内，值<= val 的个数
int query(const int &I, int val) {
    int l = L[I], r = R1[I], ret = l - 1;
    val -= tag[I]; // 剪掉懒标记
    // 特殊情况无法二分；
    if (a[l].first > val) return 0;
    while (l < r){
        int mid = l + r + 1 >> 1;
        if (a[mid].first <= val) l = mid;
        else r = mid - 1;
    }
    return r-L[I] + 1;
}

int kth(const int &l, const int &r, const int &k)
{
    if (k > r - l + 1) return -1;
    // 左端点桶的标号，右端点桶的标号
    int pl = l/K, pr = r/K, st = n+1, ed = n;
    // 在同一个桶里面
    if (pl == pr) 
    {
        tag[block + 1] = tag[pl];
        for (int i = L[pl]; i <= R1[pl]; i++) 
            // 桶里的数在范围内，有效
            if (a[i].second <= r && a[i].second >= l) a[++ed]=a[i];
        // 在后面放一个临时桶，桶里面放入在数据范围外的数
        L[block+1] = st, R1[block+1] = ed;
        // 二分答案， 左边界是0， 右边界是数列总和
        int Ll = 0, Rr = sum, ret = 0;
        while (Ll <= Rr)
        {
            // 如果答案是mid， 求出mid 在范围内的mid：
            int mid = Ll + Rr >> 1, p = query(block + 1, mid);
            for (int i = pl + 1; i<pr && p<k; i++) p+=query(i,mid);
            if (p >= k) Rr = mid - 1, ret = mid;
            else Ll = mid + 1;
        }
        return ret;
    }
    // 不在同一个桶里面
    tag[block+1] = tag[pl];
    // 处理左边界那个桶
    for (int i = L[pl]; i <= R1[pl]; i++) {
        if(a[i].second <= r & a[i].second >= l) a[++ed] = a[i];
    }
    L[block+1] = st, R1[block+1] = ed;
    // 处理有边界那个桶
    st = ed + 1, tag[block+2] = tag[pr];
    for(int i = L[pr]; i<=R1[pr]; i++) {
        if (a[i].second <=r) a[++ed] = a[i];
    }
    L[block+2] = st, R1[block+2] = ed;
    int Ll = 0, Rr = sum, ret = 0;
    while (Ll < Rr){
        int mid = (Ll + Rr) >> 1, p = query(block+1,mid) + query(block+2, mid);
        for (int i = pl + 1;i < pr && p < k; i++) p += query(i,mid);
        if (p >= k) Rr = mid;
        else Ll = mid + 1; 
    }
    return Rr;
}

void modify(const int &I, const int &l, const int &r, const int &val)
{
    int ax = 0, bx = 0;
    // 从桶的左端点到桶的右端点
    for (int i = L[I]; i <= R1[I]; i++)
    {
        // 桶里面的数，在范围内的放在B数组，并且+val, 不在范围内的加入A数组
        if (a[i].second < l || a[i].second > r)
            A[++ax] = a[i];
        else B[++bx] = a[i], B[bx].first += val;
    }
    int i = 1, j = 1, k = L[I];
    
    // 归并排序
    while (i <= ax && j <= bx) a[k++] = (A[i] < B[j] ? A[i++]:B[j++]);
    while (i <= ax) a[k++] = A[i++];
    while(j <= bx) a[k++] = B[j++];
}

void modify(const int &l, const int &r, const int &val)
{
    // 左端点在哪个桶，右端点在哪个桶
    int pl = l/K, pr = r/K;
    if (pl == pr) modify(pl, l, r, val);
    else {
        modify(pl,l,r,val), modify(pr, l, r, val);
        for (int i = pl + 1; i < pr; i++){
            tag[i] += val;
        }
    }
}
int32_t main()
{
   // STDIN
    R(n, m);
    // 桶的大小
    K = (int)(sqrt(n*log2(n)));
    // 桶的个数 
    block = n/K;
    rep(i,1,n) a[i] = {read(),i}, sum += a[i].first;
    // 从左到右处理， 每个桶的右端；
    rep(i,1,n) R1[i/K] = i;
    // 从右往左处理， 每个桶的左端
    rrep(i,n,1) L[i/K] = i;
    // 对每个桶进行排序
    rep(i,0,block) sort(a + L[i], a + R1[i] + 1);
    while (m--) {
        int opt, l, r, k;
        R(opt, l, r, k);
        if (opt == 1) W(kth(l,r,k));
        else modify(l,r,k), sum += (r-l+1)*k;
    }
}

```

## 线段树

### P3792 由乃与大母神原型和偶像崇拜

[P3792 由乃与大母神原型和偶像崇拜](https://www.luogu.com.cn/problem/P3792)

**题意** 

给你一个长为 nnn 的序列 aaa

每次两个操作：

    修改 x 位置的值为 y

    查询区间 [l,r] 是否可以重排为值域上连续的一段
    
    
**题解**

hash，线段树维护区间的平方和，最小值，最大值，通过每次查询区间最小值和最大值，计算出如果这一段合法的区间平方和，与实际的区间平方和比对，如果相等，则该区间成立，注意剪枝，

用区间值域是否等于区间长度来剪枝，该方法可能被出题人造数据hack

用到公式 $1^2 + 2^2 + 3^2 ... + n^2 = n*(1+n)*(2*n+1)/6$, 可对公式进行变形然后hash时让其自然溢出

```c++
const int N = 500000 + 10;
int n, m;

int a[N];
const int mod = 1e9 + 7;
struct node{
    int l, r;
    int mx, mi;
    int pfh;
}tr[N<<2];

void pushup(int u) {
    tr[u].mx = max(tr[u<<1].mx, tr[u<<1|1].mx);
    tr[u].mi = min(tr[u<<1].mi, tr[u<<1|1].mi);
    tr[u].pfh = (tr[u<<1].pfh + tr[u<<1|1].pfh)%mod;
}

void build(int u, int l, int r) {
    if (l == r) {
        tr[u] = {l,r,a[l],a[l],a[l]*a[l]%mod};
        return;
    }
    tr[u] = {l, r};
    int mid = l + r >> 1;
    build(u<<1, l, mid), build(u<<1|1, mid + 1, r);
    pushup(u);
}

int query1(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r)
    {
        return tr[u].mi;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    int v = INF;
    if (l <= mid) v = min(v, query1(u<<1, l, r));
    if (r > mid) v = min(v, query1(u<<1|1, l, r));
    return v;
}

int query2(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r)
    {
        return tr[u].mx;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    int v = 0;
    if (l <= mid) v = max(v, query2(u<<1, l, r));
    if (r > mid) v = max(v, query2(u<<1|1, l, r));
    return v;
}

int query3(int u, int l, int r){
    if (tr[u].l >= l && tr[u].r <= r) {
        return tr[u].pfh;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    int v = 0;
    if (l <= mid) v =  v + query3(u<<1, l, r)%mod;
    if (r > mid) v = (v + query3(u<<1|1, l, r))%mod;
    return v%mod;
}
int inv6;
int f(int len) {
    return (len)*(len+1)%mod*(2*len+1)%mod*inv6%mod;
}

void modify(int u, int x, int v)
{
    if (tr[u].l == x && tr[u].r == x)
    {
        tr[u] = {x,x,v,v,v*v%mod};
    }
    else{
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1| 1, x, v);
        pushup(u);
    }
}
int32_t main() 
{
    STDIN
    inv6 = qmi(6,mod-2,mod);
    R(n, m);
    rep(i, 1, n) R(a[i]);
    build(1,1,n);
    while (m--) {
        int opt, l, r;
        R(opt, l, r);
        if (opt == 2) {
            int mi = query1(1, l, r);
            int mx = query2(1, l, r);
            if (mx-mi != r-l) {
                W("yuanxing"); continue;
            }
            int pfh = query3(1, l, r);
            int tmp = (f(mx)-f(mi-1)+mod)%mod;

            if (tmp == pfh) W("damushen");
            else W("yuanxing");
        }
        else {
            modify(1, l, r);
        }
    }
}

```
### Naive Operations

[Naive Operations](http://acm.hdu.edu.cn/showproblem.php?pid=6315)

## 题意

给两个序列a和b，b是排列
1.a区间加1
2.求区间内所有[ai/bi]的和

## 题解

把a区间的加转化为b区间减，维护最小值mi和区间和，当mi减为0时，区间和加1

```c++
const int N = 1e5 + 10;
int a[N];

struct node{
    int l, r,mi;
    int sum;
    int lazy;
}tr[N<<2];
int n, m;
void pushup(int u) {
    tr[u].mi = min(tr[u<<1].mi,tr[u<<1|1].mi);
    tr[u].sum = tr[u<<1].sum + tr[u<<1|1].sum;
}
void pushdown(int u) {
    if (!tr[u].lazy) return;
    tr[u<<1].lazy += tr[u].lazy;
    tr[u<<1|1].lazy += tr[u].lazy;
    tr[u<<1].mi -= tr[u].lazy;
    tr[u<<1|1].mi -= tr[u].lazy;
    tr[u].lazy = 0;
}
void build(int u, int l, int r){
    if (l == r) {
        tr[u] = {l, l, a[l],0,0};
        return;
    }
    tr[u] = {l, r};
    int mid = l + r >> 1;
    build(u<<1, l, mid),build(u<<1|1, mid + 1, r);
    pushup(u);
    // W(tr[u].mi);
}

void modify(int u, int l, int r){
    // W(u, l, r,tr[u].l, tr[u].r,tr[u].mi);
    // cout<<endl;
    if (l <= tr[u].l && tr[u].r <= r && tr[u].mi > 1) {
        // debug
        // W("tr[u].mi = ", tr[u].mi);
        tr[u].lazy+=1;
        tr[u].mi-=1;
        return;
    }

    if (tr[u].l == tr[u].r && tr[u].mi == 1 ){
        // W(tr[u].l, tr[u].r);
        tr[u].mi = a[tr[u].l];
        tr[u].sum+=1;
        tr[u].lazy = 0;
        return;
    }
    pushdown(u);
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) modify(u<<1,l,r);
    if (r > mid) modify(u<<1|1, l, r);
    pushup(u);
}

int query(int u, int l, int r){
    // W(u,l,r, tr[u].l, tr[u].r, tr[u].sum);
    // cout <<endl;
    if (l <= tr[u].l && tr[u].r <= r) {
        return tr[u].sum;
    }
    if(tr[u].mi==0) modify(1,l,r);
    pushdown(u);
    int v=0;
    int mid = tr[u].l + tr[u].r >> 1;
    if (l <= mid) v += query(u<<1,l,r);
    if (r>mid) v+=query(u<<1|1,l,r);
    return v;
}
int32_t main() {
    STDIN
    while (~scanf("%d%d", &n, &m)){
    // R(n ,m);
    rep(i,1,n) R(a[i]);
    build(1,1,n);
    while (m--) {
        char s[10];
        int x,y;
        R(s, x, y);
            // W(s,x,y);
        if (s[0] == 'a'){
            modify(1,x,y);
        }
        else {
            W(query(1,x,y));
       }
    }
    }
}
```
