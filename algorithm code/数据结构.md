## 线段树

### P3792 由乃与大母神原型和偶像崇拜

[P3792 由乃与大母神原型和偶像崇拜](https://www.luogu.com.cn/problem/P3792)

**题意** 

给你一个长为 nnn 的序列 aaa

每次两个操作：

    修改 x 位置的值为 y

    查询区间 [l,r] 是否可以重排为值域上连续的一段
    
    
**题解**

hash，线段树维护区间的平方和，最小值，最大值，通过每次查询区间最小值和最大值，计算出如果这一段合法的区间平方和，与实际的区间平方和比对，如果相等，则该区间成立，注意剪枝，

用区间值域是否等于区间长度来剪枝，该方法可能被出题人造数据hack

```c++
const int N = 500000 + 10;
int n, m;

int a[N];
const int mod = 1e9 + 7;
struct node{
    int l, r;
    int mx, mi;
    int pfh;
}tr[N<<2];

void pushup(int u) {
    tr[u].mx = max(tr[u<<1].mx, tr[u<<1|1].mx);
    tr[u].mi = min(tr[u<<1].mi, tr[u<<1|1].mi);
    tr[u].pfh = (tr[u<<1].pfh + tr[u<<1|1].pfh)%mod;
}

void build(int u, int l, int r) {
    if (l == r) {
        tr[u] = {l,r,a[l],a[l],a[l]*a[l]%mod};
        return;
    }
    tr[u] = {l, r};
    int mid = l + r >> 1;
    build(u<<1, l, mid), build(u<<1|1, mid + 1, r);
    pushup(u);
}

int query1(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r)
    {
        return tr[u].mi;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    int v = INF;
    if (l <= mid) v = min(v, query1(u<<1, l, r));
    if (r > mid) v = min(v, query1(u<<1|1, l, r));
    return v;
}

int query2(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r)
    {
        return tr[u].mx;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    int v = 0;
    if (l <= mid) v = max(v, query2(u<<1, l, r));
    if (r > mid) v = max(v, query2(u<<1|1, l, r));
    return v;
}

int query3(int u, int l, int r){
    if (tr[u].l >= l && tr[u].r <= r) {
        return tr[u].pfh;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    int v = 0;
    if (l <= mid) v =  v + query3(u<<1, l, r)%mod;
    if (r > mid) v = (v + query3(u<<1|1, l, r))%mod;
    return v%mod;
}
int inv6;
int f(int len) {
    return (len)*(len+1)%mod*(2*len+1)%mod*inv6%mod;
}

void modify(int u, int x, int v)
{
    if (tr[u].l == x && tr[u].r == x)
    {
        tr[u] = {x,x,v,v,v*v%mod};
    }
    else{
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1| 1, x, v);
        pushup(u);
    }
}
int32_t main() 
{
    STDIN
    inv6 = qmi(6,mod-2,mod);
    R(n, m);
    rep(i, 1, n) R(a[i]);
    build(1,1,n);
    while (m--) {
        int opt, l, r;
        R(opt, l, r);
        if (opt == 2) {
            int mi = query1(1, l, r);
            int mx = query2(1, l, r);
            if (mx-mi != r-l) {
                W("yuanxing"); continue;
            }
            int pfh = query3(1, l, r);
            int tmp = (f(mx)-f(mi-1)+mod)%mod;

            if (tmp == pfh) W("damushen");
            else W("yuanxing");
        }
        else {
            modify(1, l, r);
        }
    }
}

```
