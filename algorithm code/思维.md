[两个二进制串循环与和](#Binary_Numbers_AND_Sum)

[Motarack's_Birthday](#Motarack's_Birthday)

[Anu_Has_a_Function](#Anu_Has_a_Function)

[Array_Sharpening](#Array_Sharpening)

[C. Element Extermination](#Element_Extermination)

## Binary_Numbers_AND_Sum

[Binary_Numbers_AND_Sum](https://codeforces.com/problemset/problem/1066/E)

**题意**

给你两个二进制序列，s1、s2 , 每次s2>>1; 结果 + s1&s2， 求最终结果

**题解**

这题很容易想到求每位的权值， 但怎么求呢？
因为s1只有为1的位才会对结果有影响，乘，s2 每位的前面1的个数（前缀和）

```c++
    rep(i, 1, m){
        sum[i] = sum[i-1];
        if (s2[i] == '1') sum[i] += 1;
    }
    int ans = 0;
    rep(i, 1, n)
    {
        if (s1[n-i+1] == '1')
        {
            if (m - i + 1 >= 1)
            ans = (ans + qmi(2, i - 1, 998244353)*(sum[m-i+1])%mod)%mod;
        }
    }
    cout << ans << endl;
```

## Motarack's_Birthday

[Motarack's Birthday](https://codeforces.com/contest/1301/problem/B)
**题意**

数列，-1代表缺失的数，你需要用k替换所有的-1，使数列所有相邻两个数的差的最大绝对值最小

**题解**

遍历一遍，找到所有和-1相邻的数的最大值和最小值。那么k是`（maxn + minn）/2`;

```c++
case{
        int n;
        n = re;
        rep(i, 1, n) a[i] = re;
        int maxn = -2;
        int minn = 2e9 + 10;
        rep(i, 1, n)
        {
            if (a[i] == -1)
            {
                if (i-1>=1 && a[i-1] != -1){
                    maxn = max(a[i-1], maxn);
                    minn = min(a[i-1], minn);
                }
                if (i + 1 <= n && a[i+1] != -1)
                {
                    maxn = max(a[i+1], maxn);
                    minn = min(a[i+1], minn);
                }
            }
        }
        int change = 0;
        if (maxn == -2 && minn == 2e9 + 10) change = 0;
        else if (maxn == -2) change = minn;
        else if (minn == 2e9 + 10) change = 2e9 + 10;
        else change = (maxn + minn)/2;
        rep(i, 1, n) if (a[i] == -1) a[i] = change;
        int ans = -1;
        rep(i, 2, n) ans = max(abs(a[i] - a[i-1]), ans);
        cout<<ans<<" " << change<<endl;
    }
```

## Anu_Has_a_Function

**题意**

定义一个函数 `f(x,y)=f(x∣y)−y`;

将序列重新排列，使f(f(…f(f(a1,a2),a3),…an−1),an) 最大；


**题解**

[Anu_Has_a_Function](https://codeforces.com/contest/1300/problem/C)

方法一、

可以发现只有当二进制的某位只有一个1的时候，才会对结果产生影响，那么我们只需要从最高位开始，找到只有一个1的位的那个数，把他往前放就好了

方法二、



```c++
 STDIN
    int n;
    n = re;
    rep(i, 1, n)
    {
        a[i] = re;
    }
    int index = -1;
    vector<int> vec;
    for (int i = 33; i >= 0; i--)
    {
        int cnt = 0;
        for (int j = 1; j <= n; j++){
            int t = (a[j] >> i) & 1;
            if (t == 1) {
                cnt++;
                index = j;
            }
            
        }
        if (cnt == 1) {
            st[index] = true;
            vec.push_back(index);
            break;
        }
        
    }
    for (auto i:vec)
    {
        cout << a[i] << " ";
    }
    for (int i = 1; i <= n; i++)
    {
        if (st[i]) continue;
        cout << a[i] << " ";
    }
    cout <<endl;
```

## Array_Sharpening

[B. Array Sharpening](https://codeforces.com/contest/1291/problem/B)

**题意**

每次可以选一个大于0的数，将它减1，问能否经过一系列操作，将序列变为山峰类的数列，一个顶

**题解**

```c++
        cin >> n;
        for (int i = 0; i < n; i++) cin >> a[i];

        int l = 0, r = n - 1;

        while (l<n && a[l] >= l) l++;
        while (r >=0 && a[r] >= n - r -1) r--; 
        if (l - 1 >= r + 1) printf("YEs\n");
        else printf("No\n");
```
## Element_Extermination

[C. Element Extermination](https://codeforces.com/contest/1375/problem/C)

**题意**
一个序列，每次如果$a[i] < a[i+1]$ 那么可以删除a[i]或者a[i+1] 能否经过多次操作，将序列转化为非下降序列
**题解**

如果a[1] < a[n] 输出yes;
否则输出no

```c++

```
