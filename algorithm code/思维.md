[两个二进制串循环与和](#Binary_Numbers_AND_Sum)

[Motarack's_Birthday](#Motarack's_Birthday)

## Binary_Numbers_AND_Sum

[Binary_Numbers_AND_Sum](https://codeforces.com/problemset/problem/1066/E)

**题意**

给你两个二进制序列，s1、s2 , 每次s2>>1; 结果 + s1&s2， 求最终结果

**题解**

这题很容易想到求每位的权值， 但怎么求呢？
因为s1只有为1的位才会对结果有影响，乘，s2 每位的前面1的个数（前缀和）

```c++
    rep(i, 1, m){
        sum[i] = sum[i-1];
        if (s2[i] == '1') sum[i] += 1;
    }
    int ans = 0;
    rep(i, 1, n)
    {
        if (s1[n-i+1] == '1')
        {
            if (m - i + 1 >= 1)
            ans = (ans + qmi(2, i - 1, 998244353)*(sum[m-i+1])%mod)%mod;
        }
    }
    cout << ans << endl;
```

## Motarack's_Birthday

[Motarack's Birthday](https://codeforces.com/contest/1301/problem/B)
**题意**

数列，-1代表缺失的数，你需要用k替换所有的-1，使数列所有相邻两个数的差的最大绝对值最小

**题解**

遍历一遍，找到所有和-1相邻的数的最大值和最小值。那么k是`（maxn + minn）/2`;

```c++
case{
        int n;
        n = re;
        rep(i, 1, n) a[i] = re;
        int maxn = -2;
        int minn = 2e9 + 10;
        rep(i, 1, n)
        {
            if (a[i] == -1)
            {
                if (i-1>=1 && a[i-1] != -1){
                    maxn = max(a[i-1], maxn);
                    minn = min(a[i-1], minn);
                }
                if (i + 1 <= n && a[i+1] != -1)
                {
                    maxn = max(a[i+1], maxn);
                    minn = min(a[i+1], minn);
                }
            }
        }
        int change = 0;
        if (maxn == -2 && minn == 2e9 + 10) change = 0;
        else if (maxn == -2) change = minn;
        else if (minn == 2e9 + 10) change = 2e9 + 10;
        else change = (maxn + minn)/2;
        rep(i, 1, n) if (a[i] == -1) a[i] = change;
        int ans = -1;
        rep(i, 2, n) ans = max(abs(a[i] - a[i-1]), ans);
        cout<<ans<<" " << change<<endl;
    }
```
