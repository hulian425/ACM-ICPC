[lca_树加边两点距离为k](#Trees_and_Queries)

## Trees_and_Queries

[E. 1-Trees and Queries](https://codeforces.com/contest/1304/problem/E)

**题意**

给你一个数组 N 表示有 N 个节点，这些节点构成一棵树，然后输入N-1条边，接下来给个 M 有M次询问每次给出 x，y，a，b，k。
增加一条 x 到 y 的距离为1的边，问你从否从a出发经过k步到达b，如果能就输出YES 否则就是NO
每次询问不考虑之前增加的边


**题解**

我们假设a到b的最短路径长度为L，显然对于任意一个非负整数z,满足存在一个a到b的路径长为L+2∗z。

所以我们只需要判断是否存在一个路径距离为L，满足：L≤k，且L与K同奇偶性。

通过分析可以得知，对于每一个询问的a，b只有以下三个有意义的路径（即其他的路径可以通过这三条路径加2∗z得到）：

1、a到b的简单路径（不使用新增加的边）。

2、a−>x−>y−>b

2、a−>y−>x−>b

分别判断是否有一条路径符合：L≤k，且L与K同奇偶性 即可。

```c++
const int N = 1e5 + 10, M = N * 2;
 
int n, m;
int h[N], e[M], ne[M], idx;
int depth[N], fa[N][21];
int q[N];
int dist[N];
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a]  , h[a] = idx ++ ;
}
 
void bfs(int root)
{
    memset(depth, 0x3f, sizeof depth);
    depth[0] = 0, depth[root] = 1;
    int hh = 0, tt = 0;
    q[0] = root;
    while (hh <= tt)
    {
        int t = q[hh ++ ];
        for (int i = h[t]; ~i; i = ne[i])
        {
            int j = e[i];
            if (depth[j] > depth[t] + 1)
            {
                depth[j] = depth[t] + 1;
                q[ ++ tt] = j;
                fa[j][0] = t;
                for (int k = 1; k <= 20; k ++ )
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
            }
        }
    }
}
 
int lca(int a, int b)
{
    if (depth[a] < depth[b]) swap(a, b);
    for (int k = 20; k >= 0; k -- )
        if (depth[fa[a][k]] >= depth[b])
            a = fa[a][k];
    if (a == b) return a;
    for (int k = 20; k >= 0; k -- )
        if (fa[a][k] != fa[b][k])
        {
            a = fa[a][k];
            b = fa[b][k];
        }
    return fa[a][0];
}
int distance(int a, int b)
{
    return depth[a] + depth[b] - 2*depth[lca(a, b)];
}
 
bool f(int d, int k)
{
    if (d <= k && ((d-k)%2 == 0)) return true;
    return false;
}
signed main()
{
    // STDIN
    memset(h, -1, sizeof h);
    n = re;
    for (int i = 1; i < n; i ++ )
    {
        int a, b;
        a = re, b = re;
        add(a, b), add(b, a);
    }
    bfs(1);
 
    m = re;
    while (m -- )
    {
        int x, y, a, b, k;
        x = re, y = re, a = re, b = re, k = re;
        int d1 = distance(a, b);
        int d2 = distance(a, x) + 1 + distance(y, b);
        int d3 = distance(a, y) + 1 + distance(x, b);
        // cout << d1 <<" " <<d2 << " " <<d3 <<endl;
        if (f(d1, k) || f(d2, k) || f(d3, k))
        {
            puts("YES");
        }
        else puts("NO");
    }
 
    return 0;
}
```
